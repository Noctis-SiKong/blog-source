---
title: '最短路径'
date: '2025-12-25T19:30:10+08:00'
draft: false
series: '数据结构与算法优化'
---

## 最短路径算法

包含Floyd-Warshall（多源最短路径）Dijkstra（单源最短路径）两种算法

<!--More-->

### 子分类 1：Floyd-Warshall（弗洛伊德，多源最短路径）

#### 核心场景（详细版）

Floyd 算法是**多源最短路径**的经典实现，可一次性求出「任意两个顶点之间」的最短路径，适合以下场景：

- 顶点数少（n≤100）：时间复杂度 O (n³)，n>100 时会超时；
- 无负权环（允许负权边）：若存在负权环，最短路径无意义；
- 需批量查询：如同时求起点 0 到所有点、点 P 到点 Q 的最短路径（如 “最短路径”“畅通工程 3” 变种）。

#### 算法思想（详细拆解）

Floyd 算法基于「动态规划」思想，核心是 “松弛操作”，步骤拆解如下：

1. **核心概念定义**：
   - 距离矩阵 dist：dist [i][j] 表示「从顶点 i 到顶点 j 的当前最短路径长度」；
   - 松弛操作（Relaxation）：对于路径 i→j，若存在中间点 k，使得 i→k→j 的路径比 i→j 更短，则更新 dist [i][j] = dist [i][k] + dist [k][j]。
2. **算法步骤**：
   - 步骤 1：初始化距离矩阵：
     - 若 i==j，dist [i][j] = 0（自身到自身距离为 0）；
     - 若 i 和 j 有直达边，dist [i][j] = 边权；
     - 若无直达边，dist [i][j] = INF（无穷大，需选合适值，避免溢出）。
   - 步骤 2：三重循环松弛操作（核心）：
     - 外层循环：枚举中间点 k（所有可能的中转点）；
     - 中层循环：枚举起点 i；
     - 内层循环：枚举终点 j；
     - 松弛判断：若 dist [i][k] < INF 且 dist [k][j] < INF（i 到 k、k 到 j 均可达），且 dist [i][k]+dist [k][j] < dist [i][j]，则更新 dist [i][j]。
   - 步骤 3：结果使用：dist [i][j] 即为 i 到 j 的最短路径长度，若 dist [i][j] == INF 则不可达。

#### 通用精简代码（注释清晰，脱离题目限制）

```java
import java.util.*;

public class Floyd {
    // 无穷大取值：10000（需大于题目中最大可能路径和，避免溢出）
    public static final int INF = 10000;

    // 通用Floyd：返回任意两点最短路径矩阵
    // 参数：n=顶点数，cost=原始邻接矩阵（cost[i][j]为i到j的直达边权，无则为INF）
    public static int[][] floyd(int n, int[][] cost) {
        int[][] dist = new int[n][n];
        // 步骤1：初始化距离矩阵
        for (int i = 0; i < n; i++) {
            System.arraycopy(cost[i], 0, dist[i], 0, n);
            dist[i][i] = 0; // 自身到自身距离强制为0
        }

        // 步骤2：三重循环松弛（k=中间点，i=起点，j=终点）
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    // 必须判断i→k、k→j可达，避免INF+INF溢出
                    if (dist[i][k] < INF && dist[k][j] < INF) {
                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }
        return dist;
    }

    // 复用入口（适配各类多源最短路径题）
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            int n = sc.nextInt(); // 顶点数
            int m = sc.nextInt(); // 查询数（按需）
            sc.nextLine();

            // 初始化原始邻接矩阵
            int[][] cost = new int[n][n];
            for (int i = 0; i < n; i++) {
                Arrays.fill(cost[i], INF);
                String[] parts = sc.nextLine().trim().split(",");
                for (int j = 0; j < n; j++) {
                    cost[i][j] = Integer.parseInt(parts[j].trim());
                }
            }

            // 执行Floyd
            int[][] dist = floyd(n, cost);

            // 示例1：输出起点0到所有可达点的排序结果（按距离升序、编号升序）
            List<Integer> nodes = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (dist[0][i] < INF) nodes.add(i);
            }
            Collections.sort(nodes, (a, b) -> dist[0][a] != dist[0][b] ? dist[0][a]-dist[0][b] : a-b);
            for (int i = 0; i < nodes.size(); i++) {
                if (i > 0) System.out.print(" <= ");
                System.out.print(nodes.get(i));
            }
            System.out.println();

            // 示例2：处理点对查询（P→Q的最短路径）
            for (int i = 0; i < m; i++) {
                int p = sc.nextInt();
                int q = sc.nextInt();
                System.out.println(dist[p][q] >= INF ? -1 : dist[p][q]);
            }
        }
        sc.close();
    }
}
```

#### 核心考点（详细解释）

1. **三重循环顺序**：必须先枚举中间点 k，再枚举 i 和 j—— 因为 Floyd 的核心是 “通过 k 松弛 i→j”，若 k 在最内层，无法利用已更新的 dist [i][k] 和 dist [k][j]；
2. **无穷大取值原则**：
   - 不能用 Integer.MAX_VALUE：因为 INF+INF 会溢出为负数，导致松弛判断错误；
   - 需选 “略大于题目中最大可能路径和” 的值（如题目中最大路径和为 9999，则选 10000）；
3. **负权边处理**：允许负权边，但不允许负权环（负权环会导致路径长度无限减小，最短路径无意义）；
4. **重边处理**：若 i 和 j 之间有多个直达边，初始化时需取权值最小的边（如 cost [i][j] = min (原 cost [i][j], 新边权)）。

#### 易错点（详细说明错误原因 + 正确做法）

| 易错点                   | 错误原因                       | 正确做法                                      |
| ------------------------ | ------------------------------ | --------------------------------------------- |
| 无穷大取值错误           | 用 Integer.MAX_VALUE 导致溢出  | 选 10000/0x3f3f3f3f 等安全值                  |
| 三重循环顺序错误         | k 在最内层，无法正确松弛       | 严格按 k→i→j 顺序循环                         |
| 松弛前未判可达           | INF+INF 溢出，更新错误值       | 先判断 dist [i][k] < INF && dist [k][j] < INF |
| 初始化未设 dist [i][i]=0 | 自身到自身距离为 INF，导致错误 | 强制设置 dist [i][i] = 0                      |

### 子分类 2.2：Dijkstra（迪杰斯特拉，单源最短路径）

#### 核心场景（详细版）

Dijkstra 算法是**单源最短路径**的最优实现（边权非负），核心目标是求「单个起点到所有其他顶点」的最短路径，适合以下场景：

- 边权非负：若有负权边，需改用 Bellman-Ford 或 SPFA；
- 顶点数中等（n≤200）：基础版 O (n²)，堆优化版 O (m log n)（适合 n>200）；
- 单次起点查询：如 “从起点 S 到终点 T 的最短路径”（如 “畅通工程 3”）。

#### 算法思想（详细拆解）

Dijkstra 算法基于「贪心策略」，核心是 “每次选距离起点最近的未访问顶点，松弛其邻接顶点”，步骤拆解如下：

1. **核心概念定义**：
   - 距离数组 dist：dist [v] 表示「从起点到顶点 v 的当前最短路径长度」；
   - 访问标记数组 visited：标记顶点是否已确定最短路径（一旦标记，不再更新）。
2. **算法步骤**：
   - 步骤 1：初始化：
     - dist [start] = 0（起点到自身距离为 0）；
     - 其余 dist [v] = INF（初始不可达）；
     - visited 数组全为 false（所有顶点未确定最短路径）。
   - 步骤 2：循环 n 次（n = 顶点数）：
     - 子步骤 1：找「未访问且 dist 最小」的顶点 u（贪心选择，该顶点的最短路径已确定）；
     - 子步骤 2：标记 u 为已访问（visited [u] = true）；
     - 子步骤 3：松弛 u 的所有邻接顶点 v：若 dist [u] + w (u,v) < dist [v]（w 为 u→v 的边权），则更新 dist [v] = dist [u] + w (u,v)。
   - 步骤 3：结果使用：dist [end] 即为起点到终点的最短路径长度，若 dist [end] == INF 则不可达。

#### 通用精简代码（邻接表版，更高效，注释清晰）

java



运行









```java
import java.util.*;

public class Dijkstra {
    // 安全无穷大：0x3f3f3f3f（十进制1061109567，相加不溢出）
    public static final int INF = 0x3f3f3f3f;

    // 通用Dijkstra：返回起点到所有顶点的最短路径数组
    // 参数：n=顶点数，adj=邻接表（adj[u]存储{v, w}，表示u→v的边权为w），start=起点
    public static int[] dijkstra(int n, List<List<int[]>> adj, int start) {
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];
        Arrays.fill(dist, INF);
        dist[start] = 0;

        for (int i = 0; i < n; i++) {
            // 步骤1：找未访问的dist最小顶点u
            int u = -1;
            int minDis = INF;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && dist[j] < minDis) {
                    minDis = dist[j];
                    u = j;
                }
            }
            if (u == -1) break; // 无可达顶点，提前结束

            // 步骤2：标记已访问，松弛邻接顶点
            visited[u] = true;
            for (int[] edge : adj.get(u)) {
                int v = edge[0];
                int w = edge[1];
                // 松弛操作：仅更新未访问顶点
                if (!visited[v] && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                }
            }
        }
        return dist;
    }

    // 复用入口（适配"畅通工程3"等单源最短路径题）
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            int n = sc.nextInt(); // 顶点数（0~n-1）
            int m = sc.nextInt(); // 边数

            // 初始化邻接表：adj[u] = {{v1, w1}, {v2, w2}}
            List<List<int[]>> adj = new ArrayList<>();
            for (int i = 0; i < n; i++) adj.add(new ArrayList<>());
            for (int i = 0; i < m; i++) {
                int u = sc.nextInt();
                int v = sc.nextInt();
                int w = sc.nextInt();
                // 无向图：双向添加边（有向图仅加u→v）
                adj.get(u).add(new int[]{v, w});
                adj.get(v).add(new int[]{u, w});
            }

            int start = sc.nextInt();
            int end = sc.nextInt();

            // 执行Dijkstra
            int[] dist = dijkstra(n, adj, start);
            System.out.println(dist[end] == INF ? -1 : dist[end]);
        }
        sc.close();
    }
}
```

#### 核心考点（详细解释）

1. **贪心策略的合理性**：因为边权非负，一旦选中距离最小的未访问顶点 u，其最短路径已确定（不可能通过其他顶点绕路得到更短路径）；
2. **邻接表 vs 邻接矩阵**：
   - 邻接矩阵版：O (n²)，适合顶点数少（n≤200）；
   - 邻接表 + 堆优化版：O (m log n)，适合边数少（m<n²）的场景（如稀疏图）；
3. **松弛操作的范围**：仅更新未访问顶点 —— 因为已访问顶点的最短路径已确定，无需再更新；
4. **无向图处理**：将无向边视为双向有向边，邻接表中同时添加 u→v 和 v→u。

#### 易错点（详细说明错误原因 + 正确做法）

| 易错点           | 错误原因                      | 正确做法                              |
| ---------------- | ----------------------------- | ------------------------------------- |
| 处理负权边       | 贪心策略失效，结果错误        | 改用 Bellman-Ford/SPFA 算法           |
| 无穷大取值错误   | 溢出导致松弛判断错误          | 用 0x3f3f3f3f（避免溢出）             |
| 重边未取最小值   | 邻接表中存储多条重边，效率低  | 初始化时判断：若 w < 现有边权则更新   |
| 提前终止条件遗漏 | 无可达顶点时，循环仍执行 n 次 | 若 u=-1（未找到最小顶点），提前 break |

### 最短路径总结（辅助记忆）

| 算法     | 核心场景               | 核心口诀                       | 关键限制               |
| -------- | ---------------------- | ------------------------------ | ---------------------- |
| Floyd    | 多源最短路径、n≤100    | 三重循环 k→i→j，松弛先判可达   | 无负权环、INF 选安全值 |
| Dijkstra | 单源最短路径、边权非负 | 选最小距离点→标记访问→松弛邻接 | 边权非负、邻接表更高效 |