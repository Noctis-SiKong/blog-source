---
title: '二叉树构建与遍历'
date: '2025-12-25T19:30:10+08:00'
draft: false
series: '数据结构与算法优化'
---

# 二叉树构建与遍历题型全解

## 一、核心算法思想总览

这 4 道题本质是**分治思想**在二叉树中的应用，核心逻辑高度统一 —— 无论给定哪两种遍历序列，都以「中序序列为分割依据，另一种序列定根节点」，通过 “拆分问题→递归求解子问题→合并结果” 构建二叉树，再按需执行遍历或反转操作。

<!--More-->

### 通用分治框架（贯穿所有题型）

1. 找根节点：从非中序序列（前序 / 后序 / 层序）中定位当前子树的根（不同序列根节点位置不同）；
2. 分割子树：在中序序列中找到根节点位置，将中序序列拆分为「左子树中序序列」和「右子树中序序列」，确定左右子树节点数；
3. 递归构建：根据左右子树节点数，拆分非中序序列，递归构建左、右子树；
4. 合并结果：当前根节点连接左右子树，形成完整二叉树。

### 辅助算法思想

- 遍历思想：前 / 中 / 后序用**深度优先搜索（DFS，递归实现）**，层序用**广度优先搜索（BFS，队列实现）**；
- 镜面反转：本质是后序 DFS—— 先递归反转子树，再交换当前节点左右子树（或先交换再递归，结果一致）。

## 二、通用基础模块（算法思想落地 + 优化代码）

### 1. 二叉树节点定义（极简核心版）

算法思想：节点是二叉树的基本单位，仅需存储值、左子节点、右子节点，无需冗余属性（如 AVL 树的 height），聚焦构建与遍历核心。

```java
private static class TreeNode {
    int val; // 节点值，统一命名val，比v更易读
    TreeNode left; // 左子节点
    TreeNode right; // 右子节点

    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
```

### 2. 通用工具方法（规避重复代码，适配所有题型）

#### （1）输入处理

算法思想：统一读取整数数组，避免`sc.nextLine()`吞换行的坑，适配多组输入场景。

```java
private static int[] readIntArray(Scanner sc, int n) {
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
        arr[i] = sc.nextInt();
    }
    return arr;
}
```

#### （2）遍历结果收集（DFS 思想落地）

算法思想：用列表收集遍历结果，替代直接打印，兼顾格式控制与灵活性，符合 DFS“先访问节点，再递归子树” 的逻辑。

```java
// 前序遍历收集（根→左→右）
private static void preCollect(TreeNode root, List<Integer> res) {
    if (root == null) return; // DFS终止条件：空节点无数据
    res.add(root.val); // 访问根
    preCollect(root.left, res); // 递归左子树
    preCollect(root.right, res); // 递归右子树
}

// 后序遍历收集（左→右→根）
private static void postCollect(TreeNode root, List<Integer> res) {
    if (root == null) return;
    postCollect(root.left, res); // 递归左子树
    postCollect(root.right, res); // 递归右子树
    res.add(root.val); // 访问根
}
```

#### （3）结果格式输出

算法思想：统一控制 “空格分隔、首尾无多余空格”，避免重复编写格式逻辑。

```java
private static void printList(List<Integer> list) {
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) System.out.print(" ");
        System.out.print(list.get(i));
    }
    System.out.println();
}
```

## 三、分题型解析（算法思想 + 代码 + 考点）

### 题型 1：玩转二叉树（前序 + 中序→构建→镜面反转→层序）

#### 核心算法思想

1. 构建思想（分治）：前序序列第一个元素是根→中序分左右子树→按左子树节点数拆分前序序列→递归构建；
2. 镜面反转思想（DFS）：遍历每个节点，交换其左右子树，再递归反转子树（本质是 “后序遍历” 逻辑，先处理子树再处理当前节点）；
3. 层序遍历思想（BFS）：用队列维护当前层节点，出队时访问，同时入队左右子节点，保证 “逐层访问” 顺序。

#### 优化代码

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] inOrder = readIntArray(sc, n); // 中序序列（分割依据）
        int[] preOrder = readIntArray(sc, n); // 前序序列（定根依据）
        sc.close();

        // 分治构建二叉树
        TreeNode root = buildFromPreAndIn(preOrder, 0, n-1, inOrder, 0, n-1);
        // DFS镜面反转
        reverseTree(root);
        // BFS层序遍历
        List<Integer> res = levelOrder(root);
        // 格式输出
        printList(res);
    }

    // 分治：前序+中序构建二叉树
    private static TreeNode buildFromPreAndIn(int[] pre, int preL, int preR, int[] in, int inL, int inR) {
        if (preL > preR || inL > inR) return null; // 分治终止：子树为空
        
        // 步骤1：找根节点（前序第一个元素）
        int rootVal = pre[preL];
        TreeNode root = new TreeNode(rootVal);
        
        // 步骤2：中序分割左右子树
        int rootIdx = -1;
        for (int i = inL; i <= inR; i++) {
            if (in[i] == rootVal) {
                rootIdx = i;
                break;
            }
        }
        int leftSize = rootIdx - inL; // 左子树节点数（分治关键：确定子问题规模）
        
        // 步骤3：递归构建左右子树（分治求解子问题）
        root.left = buildFromPreAndIn(pre, preL+1, preL+leftSize, in, inL, rootIdx-1);
        root.right = buildFromPreAndIn(pre, preL+leftSize+1, preR, in, rootIdx+1, inR);
        
        return root; // 合并结果：返回当前子树根
    }

    // DFS：镜面反转二叉树
    private static void reverseTree(TreeNode root) {
        if (root == null) return; // DFS终止
        // 交换当前节点左右子树
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        // 递归反转子树（处理子问题）
        reverseTree(root.left);
        reverseTree(root.right);
    }

    // BFS：层序遍历
    private static List<Integer> levelOrder(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root); // 根节点入队（初始化当前层）
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll(); // 出队访问
            res.add(node.val);
            // 左右子节点入队（维护下一层）
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        return res;
    }

    // 通用工具方法（输入+输出）
    private static int[] readIntArray(Scanner sc, int n) { /* 同前文，省略重复代码 */ }
    private static void printList(List<Integer> list) { /* 同前文，省略重复代码 */ }
}
```

#### 期末考点

- 分治思想在 “前序 + 中序构建” 中的落地（根定位、子树分割）；
- BFS 实现层序遍历的队列用法；
- 镜面反转的 DFS 逻辑（交换左右子树的时机）。

### 题型 2：Tree Traversals Again and Again（层序 + 中序→构建→前序 + 后序）

#### 核心算法思想

1. 构建思想（分治 + 筛选）：层序第一个元素是根→中序分左右子树→从层序剩余元素中 “筛选” 出属于左 / 右子树的节点（按中序区间判断）→递归构建；
2. 遍历思想：前序 / 后序均为 DFS，仅访问节点的时机不同（根的位置不同）。

#### 优化代码

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] levelOrder = readIntArray(sc, n); // 层序序列（定根依据）
        int[] inOrder = readIntArray(sc, n); // 中序序列（分割+筛选依据）
        sc.close();

        // 分治+筛选构建二叉树
        TreeNode root = buildFromLevelAndIn(levelOrder, inOrder, 0, n-1);
        // DFS收集前序、后序结果
        List<Integer> preRes = new ArrayList<>();
        List<Integer> postRes = new ArrayList<>();
        preCollect(root, preRes);
        postCollect(root, postRes);
        // 输出
        printList(preRes);
        printList(postRes);
    }

    // 分治+筛选：层序+中序构建二叉树
    private static TreeNode buildFromLevelAndIn(int[] level, int[] in, int inL, int inR) {
        if (level.length == 0 || inL > inR) return null; // 分治终止
        
        // 步骤1：找根节点（层序第一个元素）
        int rootVal = level[0];
        TreeNode root = new TreeNode(rootVal);
        
        // 步骤2：中序分割左右子树
        int rootIdx = -1;
        for (int i = inL; i <= inR; i++) {
            if (in[i] == rootVal) {
                rootIdx = i;
                break;
            }
        }
        
        // 步骤3：筛选层序中的左右子树节点（分治关键：子序列构建）
        List<Integer> leftLevel = new ArrayList<>();
        List<Integer> rightLevel = new ArrayList<>();
        for (int i = 1; i < level.length; i++) {
            int val = level[i];
            // 判断节点属于左/右子树（依据中序区间）
            if (isInRange(val, in, inL, rootIdx-1)) {
                leftLevel.add(val);
            } else {
                rightLevel.add(val);
            }
        }
        
        // 步骤4：递归构建左右子树（分治求解）
        int[] leftArr = leftLevel.stream().mapToInt(Integer::intValue).toArray();
        int[] rightArr = rightLevel.stream().mapToInt(Integer::intValue).toArray();
        root.left = buildFromLevelAndIn(leftArr, in, inL, rootIdx-1);
        root.right = buildFromLevelAndIn(rightArr, in, rootIdx+1, inR);
        
        return root;
    }

    // 辅助：判断值是否在中序指定区间（筛选依据）
    private static boolean isInRange(int val, int[] in, int start, int end) {
        for (int i = start; i <= end; i++) {
            if (in[i] == val) return true;
        }
        return false;
    }

    // 通用方法（DFS收集+输入输出）
    private static void preCollect(TreeNode root, List<Integer> res) { /* 同前文 */ }
    private static void postCollect(TreeNode root, List<Integer> res) { /* 同前文 */ }
    private static int[] readIntArray(Scanner sc, int n) { /* 同前文 */ }
    private static void printList(List<Integer> list) { /* 同前文 */ }
}
```

#### 期末考点

- 层序构建的核心：如何筛选子树的层序序列（中序区间是关键）；
- 分治思想在非连续序列（筛选后）中的应用；
- DFS 遍历的节点访问时机（前序 vs 后序）。

### 题型 3：树的遍历（后序 + 中序→构建→前序）

#### 核心算法思想

1. 构建思想（分治）：后序序列最后一个元素是根→中序分左右子树→按右子树节点数拆分后序序列（后序序列为 “左→右→根”，右子树在根左侧）→递归构建；
2. 前序遍历思想：DFS，先访问根，再递归左右子树。

#### 优化代码

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] postOrder = readIntArray(sc, n); // 后序序列（定根依据）
        int[] inOrder = readIntArray(sc, n); // 中序序列（分割依据）
        sc.close();

        // 分治构建二叉树
        TreeNode root = buildFromPostAndIn(postOrder, 0, n-1, inOrder, 0, n-1);
        // DFS收集前序结果
        List<Integer> preRes = new ArrayList<>();
        preCollect(root, preRes);
        // 按题目格式输出
        System.out.print("Preorder: ");
        printList(preRes);
    }

    // 分治：后序+中序构建二叉树
    private static TreeNode buildFromPostAndIn(int[] post, int postL, int postR, int[] in, int inL, int inR) {
        if (postL > postR || inL > inR) return null; // 分治终止
        
        // 步骤1：找根节点（后序最后一个元素）
        int rootVal = post[postR];
        TreeNode root = new TreeNode(rootVal);
        
        // 步骤2：中序分割左右子树
        int rootIdx = -1;
        for (int i = inL; i <= inR; i++) {
            if (in[i] == rootVal) {
                rootIdx = i;
                break;
            }
        }
        int rightSize = inR - rootIdx; // 右子树节点数（分治关键：后序先右后左）
        
        // 步骤3：递归构建左右子树（分治求解）
        root.left = buildFromPostAndIn(post, postL, postR - rightSize - 1, in, inL, rootIdx-1);
        root.right = buildFromPostAndIn(post, postR - rightSize, postR - 1, in, rootIdx+1, inR);
        
        return root;
    }

    // 通用方法（DFS收集+输入输出）
    private static void preCollect(TreeNode root, List<Integer> res) { /* 同前文 */ }
    private static int[] readIntArray(Scanner sc, int n) { /* 同前文 */ }
    private static void printList(List<Integer> list) { /* 同前文，省略换行 */ }
}
```

#### 期末考点

- 后序构建的根定位（最后一个元素）与子树分割（按右子树节点数，易错点）；
- 前序遍历的 DFS 实现与格式控制（题目要求前缀 “Preorder:”）。

## 四、通用构建模板（算法思想 + 代码对应表）

| 遍历组合    | 算法思想核心                        | 根节点位置   | 子树分割 / 筛选方式                                          |
| ----------- | ----------------------------------- | ------------ | ------------------------------------------------------------ |
| 前序 + 中序 | 分治（前序定根，中序分左右）        | 前序 [preL]  | 左子树节点数 = rootIdx-inL；前序左：preL+1~preL+leftSize；前序右：preL+leftSize+1~preR |
| 后序 + 中序 | 分治（后序定根，中序分左右）        | 后序 [postR] | 右子树节点数 = inR-rootIdx；后序右：postR-rightSize~postR-1；后序左：postL~postR-rightSize-1 |
| 层序 + 中序 | 分治 + 筛选（层序定根，中序分左右） | 层序 [0]     | 遍历层序剩余元素，按中序区间筛选左 / 右子树节点，生成子层序序列递归 |

## 五、易错点总结（算法思想层面避坑）

1. 递归终止条件遗漏：分治必须判断 “子树为空”（如`preL>preR`），否则栈溢出，本质是未考虑分治的最小子问题（空树）；
2. 子树区间计算错误：后序构建易混淆 “左 / 右子树节点数”，核心是记住 “后序序列顺序为左→右→根”，右子树在根左侧紧邻；
3. 层序筛选逻辑错误：必须跳过根节点，仅筛选剩余元素，且判断依据是 “是否在中序对应子区间”，本质是保证分治子问题的正确性；
4. 遍历格式错误：统一用 “列表收集 + 遍历输出”，避免直接打印导致的首尾空格问题，本质是分离 “遍历逻辑” 与 “输出逻辑”，降低耦合。

## 六、复习建议

1. 先吃透分治思想：手动模拟 1 道样例的构建过程（如画递归树，标注每一步根、左子树、右子树），理解 “拆分→递归→合并” 的闭环；
2. 背诵通用模板：记住 3 种遍历组合的 “根节点位置” 和 “子树分割方式”，代码仅需替换这两处核心逻辑；
3. 区分 DFS/BFS 场景：前 / 中 / 后序用 DFS（递归），层序用 BFS（队列），镜面反转本质是 DFS 的变形；
4. 精简代码记忆：保留通用工具方法，聚焦核心构建逻辑，避免冗余代码干扰记忆（如去掉 AVL 树无关属性）。