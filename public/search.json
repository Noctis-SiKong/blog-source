
      
      
      
    
      
      
      
    [{"authors":null,"categories":null,"content":"","date":1765379230,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1765391505,"objectID":"bd074b4d0036b130090450159ee882ca","permalink":"http://localhost:1313/post/articles-01/","publishdate":"2025-12-10T23:07:10+08:00","relpermalink":"/post/articles-01/","section":"post","summary":"","tags":null,"title":"Articles 01","type":"post"},{"authors":null,"categories":null,"content":"村村通问题的本质 最小生成树（MST）\nKruskal 算法思路 Kruskal（克鲁斯卡尔）算法是求解无向图最小生成树（MST） 的经典贪心算法，核心逻辑是：按边的权重从小到大依次选边，且保证选的边不形成环，直到选够「节点数 - 1」条边（生成树的边数固定为节点数 - 1）。\n该算法的关键是「贪心选边」+「并查集（Union-Find）判环 / 合并集合」，专门适配 “村村通” 这类求最小连通成本的问题，以下是分步骤的详细思路：\n步骤拆解（结合 “村村通” 场景） 假设场景：有 N 个村落（节点），M 条可选道路（边），每条道路有建设成本（边的权重），目标是用最低成本让所有村落连通。\n步骤 1：预处理 —— 边按权重升序排序 将所有候选道路（边）按照建设成本（权重）从小到大排序。\n贪心逻辑：优先选成本最低的道路，是实现 “最小总成本” 的核心。 例如样例中，先排序出权重 1 的边（3-5、3-6），再是权重 2 的边（2-5、1-6），依此类推。 步骤 2：初始化并查集 并查集是一种高效管理 “集合归属” 的数据结构，用于快速判断「两个村落是否已连通」（避免选边形成环）、「合并两个不连通的村落集合」。\n初始化：每个村落独立为一个集合（即每个节点的父节点指向自己）。 例如样例中，初始时村落 1、2、3、4、5、6 各自为一个独立集合。 步骤 3：贪心遍历选边（核心步骤） 遍历排序后的所有边，对每条边执行以下判断：\n判环：用并查集的 find 方法，查找当前边的两个村落的「根节点」： 若两个根节点相同：说明两个村落已连通，选这条边会形成环，跳过。 若两个根节点不同：说明两个村落未连通，选这条边不会形成环，执行下一步。 合并 + 累加成本： 用并查集的 union 方法，将两个村落的集合合并（让它们连通）。 累加这条边的成本到总费用中。 记录已选边数（生成树需要「N-1」条边）。 步骤 4：终止条件与结果判断 终止条件：当已选边数达到「N-1」时，停止遍历（生成树已形成，无需继续选边）。 结果判断： 若已选边数 = N-1：总累加成本即为 “村村通” 的最低成本。 若遍历完所有边，已选边数 \u0026lt; N-1：说明村落无法全部连通（如存在多个孤立的连通分量），输出 - 1。 关键支撑：并查集的作用 Kruskal 算法的效率依赖并查集的两个核心操作（均做了优化）：\nfind(x)：查找节点 x 的根节点，通过「路径压缩」将 x 直接指向根节点，后续查询复杂度近似 O (1)。 union(x,y)：合并 x 和 y 所在的集合（通常简单合并或按秩合并），保证集合管理的高效性。 Kruskal 算法复杂度分析 时间复杂度：主要由「边排序」决定，为 O(M log M)（M 为边数）；并查集的 find/union 操作近似 O (1)，整体复杂度为 O(M log M)。 适用场景：适合稀疏图（边数少），本题中 M≤3N（N≤1000），属于稀疏图，非常适配 Kruskal 算法。 总结 Kruskal 算法的核心可概括为：“排序边 + 查环（并查集）+ 选边（无环则加）”，贪心策略保证了选边的最小成本，并用查集高效避免环的形成，最终得到无环、连通、总权重最小的生成树。\nJava 代码实现 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt; import java.util.Arrays; import java.util.Scanner; // 定义边类，实现Comparable接口用于按权重排序 class Edge implements Comparable\u0026lt;Edge\u0026gt; { int u; // 起点城镇 int v; // 终点城镇 int weight; // 改建成本 public Edge(int u, int v, int weight) { this.u = u; this.v = v; this.weight = weight; } // 按权重升序排序 @Override public int compareTo(Edge o) { return this.weight - o.weight; } } public class Main { private static int[] parent; // 并查集父节点数组 // 查找根节点（带路径压缩，优化查询效率） private static int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 路径压缩：将节点直接指向根 } return parent[x]; } // 合并两个集合 private static void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { parent[rootY] = rootX; // 将y的根节点指向x的根节点 } } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 多组测试数据处理 while (scanner.hasNextInt()) { int N = scanner.nextInt(); // 城镇数目 int M = scanner.nextInt(); // 候选道路数目 Edge[] edges = new Edge[M]; // 读取所有候选道路 for (int i = 0; i \u0026lt; M; i++) { int u = scanner.nextInt(); int v = scanner.nextInt(); int weight = scanner.nextInt(); edges[i] = new Edge(u, v, weight); } // 按权重升序排序边 Arrays.sort(edges); // 初始化并查集：每个城镇初始为自身的父节点 parent = new int[N + 1]; // 城镇编号从1到N，索引0不用 for (int i = 1; i \u0026lt;= N; i++) { parent[i] = i; } int selectedEdges = 0; // 已选边数（目标：N-1） int totalCost = 0; // 最小总成本 // 遍历排序后的边，贪心选边 for (Edge edge : edges) { int rootU = find(edge.u); int rootV = find(edge.v); // 若两个城镇不属于同一集合，合并并累加成本 if (rootU != rootV) { union(rootU, rootV); totalCost += edge.weight; selectedEdges++; // 选够N-1条边，提前终止 if (selectedEdges == N - 1) { break; } } } // 输出结果：选够N-1条边则输出总成本，否则输出-1 if (selectedEdges == N - 1) { System.out.println(totalCost); } else { System.out.println(-1); } } scanner.close(); } } \u0026lt;/summary\u0026gt; ","date":1765379230,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1765391559,"objectID":"4a1b2e0ccb478f41af0aa3dc0b27a9e5","permalink":"http://localhost:1313/post/%E6%9D%91%E6%9D%91%E9%80%9A%E9%97%AE%E9%A2%98/","publishdate":"2025-12-10T23:07:10+08:00","relpermalink":"/post/%E6%9D%91%E6%9D%91%E9%80%9A%E9%97%AE%E9%A2%98/","section":"post","summary":"村村通问题的本质 最小生成树（MST）\nKruskal 算法思路 Kruskal（克鲁斯卡尔）算法是求解无向图最小生成树（MST） 的经典贪心算法，核心逻辑是：按边的权重从小到大依次选边，且保证选的边不形成环，直到选够「节点数 - 1」条边（生成树的边数固定为节点数 - 1）。\n","tags":null,"title":"村村通问题01","type":"post"}]