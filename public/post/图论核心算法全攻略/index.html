<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script type=application/javascript src=https://noctis-sikong.github.io/js/theme-mode.js></script><link rel=stylesheet href=https://noctis-sikong.github.io/css/frameworks.min.css><link rel=stylesheet href=https://noctis-sikong.github.io/css/github.min.css><link rel=stylesheet href=https://noctis-sikong.github.io/css/github-style.css><link rel=stylesheet href=https://noctis-sikong.github.io/css/light.css><link rel=stylesheet href=https://noctis-sikong.github.io/css/dark.css><link rel=stylesheet href=https://noctis-sikong.github.io/css/syntax.css><title>图论核心算法全攻略 - 一切都是命运石之门的选择！</title><link rel=icon type=image/x-icon href=/R-C.png><meta name=theme-color content="#1e2327"><link rel=stylesheet href=https://noctis-sikong.github.io/css/custom.css><script type=text/javascript src=https://noctis-sikong.github.io/js/custom.js></script><meta name=description content="图论核心算法全攻略（含 10 大算法 + 场景速选） 图论是数据结构与算法优化的核心模块，也是笔试、面试、期末考试的高频考点。很多学习者的核心痛点是：面对一道图论题，既分不清 “拓扑排序 / 并查集 / DFS” 该选谁，也不知道除了基础 6 大算法外，还有哪些核心算法适配特殊场景。
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://noctis-sikong.github.io/post/%E5%9B%BE%E8%AE%BA%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A8%E6%94%BB%E7%95%A5/><meta name=twitter:card content="summary"><meta name=twitter:title content="图论核心算法全攻略 - 一切都是命运石之门的选择！"><meta name=twitter:description content="图论核心算法全攻略（含 10 大算法 + 场景速选） 图论是数据结构与算法优化的核心模块，也是笔试、面试、期末考试的高频考点。很多学习者的核心痛点是：面对一道图论题，既分不清 “拓扑排序 / 并查集 / DFS” 该选谁，也不知道除了基础 6 大算法外，还有哪些核心算法适配特殊场景。
"><meta name=twitter:site content="https://noctis-sikong.github.io/"><meta name=twitter:creator content><meta name=twitter:image content="https://noctis-sikong.github.io/"><meta property="og:type" content="article"><meta property="og:title" content="图论核心算法全攻略 - 一切都是命运石之门的选择！"><meta property="og:description" content="图论核心算法全攻略（含 10 大算法 + 场景速选） 图论是数据结构与算法优化的核心模块，也是笔试、面试、期末考试的高频考点。很多学习者的核心痛点是：面对一道图论题，既分不清 “拓扑排序 / 并查集 / DFS” 该选谁，也不知道除了基础 6 大算法外，还有哪些核心算法适配特殊场景。
"><meta property="og:url" content="https://noctis-sikong.github.io/post/%E5%9B%BE%E8%AE%BA%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A8%E6%94%BB%E7%95%A5/"><meta property="og:site_name" content="图论核心算法全攻略"><meta property="og:image" content="https://noctis-sikong.github.io/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2025-12-25 19:30:10 +0800 CST"></head><body><div style=position:relative><header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on"><div class="Header-item mobile-none" style=margin-top:-4px;margin-bottom:-4px><a class=Header-link href=https://noctis-sikong.github.io/><img class=octicon height=32 width=32 src=/R-C.png></a></div><div class="Header-item d-md-none"><button class="Header-link btn-link js-details-target" type=button onclick='document.querySelector("#header-search").style.display=document.querySelector("#header-search").style.display=="none"?"block":"none"'>
<svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button></div><div style=display:none id=header-search class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex"><div class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to"><div class=position-relative><form target=_blank action=https://www.google.com/search method=get autocomplete=off><label class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center"><input type=text class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable" name=q placeholder=Search autocomplete=off onfocus='this.value=""'>
<input type=hidden name=as_sitesearch value=https://noctis-sikong.github.io/></label></form></div></div><div class="Header-item d-md-flex align-items-center mb-3 mb-md-0"><a class=Header-link href=https://noctis-sikong.github.io/series/ style=color:inherit;text-decoration:none><svg height="16" class="octicon octicon-book" viewBox="0 0 16 16" width="16" style="margin-right:4px"><path fill-rule="evenodd" d="M0 1.75A.75.75.0 01.75 1h4.253C6.23 1 7.32 1.59 7.92 2.504l.709.923a.75.75.0 01-.257 1.08l-.79.323A2.25 2.25.0 015.25 6H2.75a.75.75.0 010-1.5h1.714a.75.75.0 00.672-.428L5.146 2.5H1.5v9h3.75a.75.75.0 010 1.5H.75A.75.75.0 010 12.25V1.75zm6.75 4A.75.75.0 017.5 5h2.998a.75.75.0 01.75.75v8.5a.75.75.0 01-.75.75H7.5a.75.75.0 01-.75-.75V5.75z"/></svg>
我的专栏</a></div></div><div class="Header-item Header-item--full flex-justify-center d-md-none position-relative"><a class=Header-link href=https://noctis-sikong.github.io/><img class="octicon octicon-mark-github v-align-middle" height=32 width=32 src=/R-C.png></a></div><div class="Header-item d-md-none mr-2"><a class=Header-link href=https://noctis-sikong.github.io/series/ style=color:inherit;text-decoration:none><svg height="16" class="octicon octicon-book" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M0 1.75A.75.75.0 01.75 1h4.253C6.23 1 7.32 1.59 7.92 2.504l.709.923a.75.75.0 01-.257 1.08l-.79.323A2.25 2.25.0 015.25 6H2.75a.75.75.0 010-1.5h1.714a.75.75.0 00.672-.428L5.146 2.5H1.5v9h3.75a.75.75.0 010 1.5H.75A.75.75.0 010 12.25V1.75zm6.75 4A.75.75.0 017.5 5h2.998a.75.75.0 01.75.75v8.5a.75.75.0 01-.75.75H7.5a.75.75.0 01-.75-.75V5.75z"/></svg></a></div><div class=Header-item style=margin-right:0><a href=javascript:void(0) class="Header-link no-select" onclick=switchTheme()><svg style="fill:var(--color-profile-color-modes-toggle-moon)" class="no-select" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.52208 7.71754c3.05612.0 5.53362-2.47748 5.53362-5.5336C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961 9.95801 1.07727 10.3495.771159 10.6474.99992c1.4679 1.12724 2.4141 2.90007 2.4141 4.89391.0 3.40575-2.7609 6.16667-6.16665 6.16667-2.94151.0-5.40199-2.0595-6.018122-4.81523C.794841 6.87902 1.23668 6.65289 1.55321 6.85451 2.41106 7.40095 3.4296 7.71754 4.52208 7.71754z"/></svg></a></div></header></div><div id=search-result class="container-lg px-3 new-discussion-timeline" style=display:none></div><div class=application-main><div><main><div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4"><div class=px-0><div class="mb-3 d-flex px-3 px-md-3 px-lg-5"><div class="flex-auto min-width-0 width-fit mr-3"><div class=d-flex><div class="d-none d-md-block"><a class="avatar mr-2 flex-shrink-0" href=https://noctis-sikong.github.io/><img class=avatar-user src=/%e5%85%8b%e9%87%8c%e6%96%af.jpg width=32 height=32></a></div><div class="d-flex flex-column"><h1 class="break-word f3 text-normal mb-md-0 mb-1"><span class=author><a href=https://noctis-sikong.github.io/>天才变态少女</a>
</span><span class=path-divider>/</span>
<strong class="css-truncate css-truncate-target mr-1" style=max-width:410px><a href=https://noctis-sikong.github.io/post/%E5%9B%BE%E8%AE%BA%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A8%E6%94%BB%E7%95%A5/>图论核心算法全攻略</a></strong></h1><div class="note m-0">Created <relative-time datetime="Thu, 25 Dec 2025 19:30:10 +0800" class=no-wrap>Thu, 25 Dec 2025 19:30:10 +0800</relative-time>
<span class=file-info-divider></span>
Modified <relative-time datetime="Sun, 04 Jan 2026 17:27:26 +0800" class=no-wrap>Sun, 04 Jan 2026 17:27:26 +0800</relative-time></div></div></div></div></div></div></div><div class="container-lg px-3 new-discussion-timeline"><div class="repository-content gist-content"><div><div class="js-gist-file-update-container js-task-list-container file-box"><div id=file-pytest class="file my-2"><div id=post-header class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style=z-index:2><div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto"><div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0"><summary id=toc-toggle onclick=clickToc() class="btn btn-octicon m-0 mr-2 p-2"><svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered"><path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75.0 000 1.5h8.5a.75.75.0 000-1.5h-8.5zm0 5a.75.75.0 000 1.5h8.5a.75.75.0 000-1.5h-8.5zm0 5a.75.75.0 000 1.5h8.5a.75.75.0 000-1.5h-8.5zM3 8A1 1 0 111 8a1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"/></svg></summary><details-menu class=SelectMenu id=toc-details style="display: none;"><div class="SelectMenu-modal rounded-3 mt-1" style=max-height:340px><div class="SelectMenu-list SelectMenu-list--borderless p-2" style=overscroll-behavior:contain id=toc-list></div></div></details-menu>5369 Words</div><div class="file-actions flex-order-2 pt-0"></div></div></div><div class="Box-body px-5 pb-5" style=z-index:1><article class="markdown-body entry-content container-lg"><h1 id=图论核心算法全攻略含-10-大算法--场景速选>图论核心算法全攻略（含 10 大算法 + 场景速选）</h1><p>图论是数据结构与算法优化的核心模块，也是笔试、面试、期末考试的高频考点。很多学习者的核心痛点是：面对一道图论题，既分不清 “拓扑排序 / 并查集 / DFS” 该选谁，也不知道除了基础 6 大算法外，还有哪些核心算法适配特殊场景。</p><p>本文将系统梳理<strong>10 类图论核心算法</strong>（包含你指定的拓扑排序、Floyd、Dijkstra、Prim、DFS/BFS、并查集 6 个必选算法，额外补充 4 类高频核心算法），按 “场景特征→最优算法→选择原因→避坑指南” 的逻辑拆解，帮你建立 “看场景选算法” 的思维，无论是期末复习还是实战刷题都能直接套用。</p><h2 id=一图论算法选择的底层逻辑先记这-3-步>一、图论算法选择的底层逻辑（先记这 3 步）</h2><p>选择图论算法无需死记硬背，只需按以下 3 步判断，就能快速锁定最优解：</p><ol><li><strong>定目标</strong>：明确问题核心诉求（排序 / 判环？最短路径？连通性？最小生成树？网络流？）；</li><li><strong>看图特性</strong>：区分图的类型（有向 / 无向？稠密 / 稀疏？边权非负 / 含负权？是否有环？）；</li><li><strong>看数据规模</strong>：顶点数 n、边数 m 的大小（决定算法效率是否达标，比如 n>100 时 Floyd 会超时）。</li></ol><h2 id=二全场景算法选择对照表核心精华>二、全场景算法选择对照表（核心精华）</h2><table><thead><tr><th>核心场景</th><th>典型题型特征</th><th>最优算法</th><th>包含关系</th><th>选择原因</th><th>典型例题</th><th>关键注意点</th></tr></thead><tbody><tr><td>有向图排序 + 环检测</td><td>1. 有向图；2. 需按依赖关系排序；3. 需判断是否有环（DAG 验证）</td><td>拓扑排序（Kahn）</td><td>必选</td><td>1. 时间复杂度 O (n+m)，适配 n≤1000 的场景；2. 迭代版（队列）避免栈溢出；3. 天然支持环检测</td><td>课程表、拓扑排序（DS toplogical sort v1）</td><td>1. 1 基顶点转 0 基处理；2. 结果长度≠顶点数 = 有环；3. 入度统计不能遗漏</td></tr><tr><td>多源最短路径查询</td><td>1. 任意两点间最短路径；2. n≤100（稠密图）；3. 允许负权边（无负权环）</td><td>Floyd-Warshall</td><td>必选</td><td>1. 实现最简单（三重循环）；2. 一次性生成所有点对结果；3. O (n³) 仅 n≤100 可行</td><td>最短路径（多源查询版）</td><td>1. INF 选 10000 避免溢出；2. 循环顺序 k→i→j；3. 松弛前判可达</td></tr><tr><td>单源最短路径（边权非负）</td><td>1. 单个起点到所有 / 指定终点的最短路径；2. 边权非负；3. n≤200（或堆优化适配更大 n）</td><td>Dijkstra</td><td>必选</td><td>1. 贪心策略效率高（基础版 O (n²)，堆优化 O (m log n)）；2. 边权非负时无更优解</td><td>畅通工程 3、单源最短路径</td><td>1. 边权非负是前提；2. 邻接表版适配稀疏图；3. 无向图双向加边</td></tr><tr><td>最小生成树（稠密无向图）</td><td>1. 无向图；2. 连接所有顶点且总边权最小；3. 稠密图（边数多，n≤1000）</td><td>Prim</td><td>必选</td><td>1. 基础版 O (n²) 适配稠密图；2. 无需排序边，实现更简洁；3. 天然支持连通性判断</td><td>公路村村通、畅通工程 2</td><td>1. dist 数组是 “到 MST 的最小边权”（区别 Dijkstra）；2. 用访问顶点数判连通</td></tr><tr><td>连通分量遍历 / 统计（需顶点）</td><td>1. 无向图；2. 需输出连通分量具体顶点；3. 需按指定顺序遍历</td><td>DFS/BFS</td><td>必选</td><td>1. 直观易实现，可控制遍历顺序；2. O (n+m) 适配 n≤1000；3. 兼顾遍历和统计</td><td>列出连通集</td><td>1. 邻接表排序保证编号递增；2. BFS 入队时标记访问；3. 无向图双向加边</td></tr><tr><td>连通性快速查询（大规模）</td><td>1. 仅判断两点连通 / 统计分量数；2. 大规模数据（n≤10000）；3. 无需输出具体顶点</td><td>并查集（路径压缩 + 秩合）</td><td>必选</td><td>1. find/union 近似 O (1)，效率远超 DFS/BFS；2. 代码简洁，适配海量边</td><td>畅通工程 1、朋友圈</td><td>1. 合并前先找根节点；2. 必须路径压缩；3. 统计分量数需调用 find</td></tr><tr><td>最小生成树（稀疏无向图）</td><td>1. 无向图；2. 连接所有顶点且总边权最小；3. 稀疏图（边数 m&lt;n²）</td><td>Kruskal</td><td>补充</td><td>1. 边排序 + 并查集实现，O (m log m) 适配稀疏图；2. 比 Prim 更高效（无需遍历顶点）</td><td>最小生成树（稀疏版）</td><td>1. 边按权值升序排序；2. 用并查集判环；3. 累计边权直到选够 n-1 条边</td></tr><tr><td>单源最短路径（负权边 / 判环）</td><td>1. 单个起点最短路径；2. 含负权边；3. 需判断负权环</td><td>Bellman-Ford/SPFA</td><td>补充</td><td>1. 适配负权边场景；2. SPFA 是 Bellman-Ford 优化版，效率更高；3. 可检测负权环</td><td>负权边最短路径、判负权环</td><td>1. SPFA 用队列实现；2. 用入队次数 > n 判断负权环；3. 避免松弛已确定的顶点</td></tr><tr><td>强连通分量 / 割点割边</td><td>1. 有向图找强连通分量；2. 无向图找割点 / 割边；3. 需缩点处理</td><td>Tarjan</td><td>补充</td><td>1. 一次 DFS 完成所有计算；2. O (n+m) 适配绝大多数场景；3. 兼顾多种连通问题</td><td>强连通分量、网络冗余链路</td><td>1. 维护 dfn/low 数组；2. 处理递归栈；3. 无向图需跳过父节点</td></tr><tr><td>欧拉路径 / 回路（一笔画）</td><td>1. 无向 / 有向图；2. 判断是否存在欧拉路径 / 回路；3. 输出具体路径</td><td>Fleury 算法</td><td>补充</td><td>1. 贪心选边 + 删边实现；2. 直接输出路径；3. 适配 n≤1000</td><td>一笔画问题、欧拉回路</td><td>1. 先判断度数条件（无向图：0/2 个奇度点）；2. 避免走桥（除非无其他边）</td></tr><tr><td>网络最大流</td><td>1. 有向图；2. 源点→汇点最大流量；3. 边有容量限制</td><td>Dinic 算法</td><td>补充</td><td>1. 分层图 + DFS 增广，是最大流最优算法；2. O (n²m) 适配绝大多数场景</td><td>网络最大流、水流分配</td><td>1. 构建残量网络；2. BFS 分层；3. DFS 找增广路并更新残量</td></tr></tbody></table><h2 id=三分算法深度解析期末--实战双适配>三、分算法深度解析（期末 / 实战双适配）</h2><h3 id=一必选算法6-大核心重点巩固>（一）必选算法：6 大核心（重点巩固）</h3><h4 id=1-拓扑排序kahn-算法>1. 拓扑排序（Kahn 算法）</h4><h5 id=什么时候用>什么时候用？</h5><p>只要遇到「有向图依赖排序 + 环检测」场景，优先选拓扑排序，比如：课程安排（先修课→后修课）、任务调度（依赖任务执行顺序）、验证有向图是否为 DAG（无环图）。</p><h5 id=核心优势>核心优势</h5><ul><li>迭代版（队列 + 入度）比递归版更稳定，避免顶点数多导致的栈溢出；</li><li>时间复杂度 O (n+m)，适配绝大多数高校期末题的 n≤1000 场景；</li><li>天然支持环检测（结果长度 &lt; 顶点数 = 有环），无需额外逻辑。</li></ul><h5 id=避坑指南>避坑指南</h5><ul><li>顶点编号：题目常给 1 基顶点，代码中统一转 0 基处理（避免数组越界），输出时再转回 1 基；</li><li>入度统计：遍历邻接表时，对每个 u 的邻接顶点 v，必须执行<code>inDegree[v]++</code>，遗漏会导致排序错误；</li><li>判环逻辑：不要仅判断队列是否为空，必须用「结果长度 = 顶点数」验证无环。</li></ul><h4 id=2-floyd-warshall多源最短路径>2. Floyd-Warshall（多源最短路径）</h4><h5 id=什么时候用-1>什么时候用？</h5><p>需「一次性求任意两点最短路径」，且顶点数 n≤100（稠密图），允许负权边（但无负权环），比如：小范围地图的所有点对最短路径查询。</p><h5 id=核心优势-1>核心优势</h5><ul><li>实现最简单的图论算法之一，仅需三重循环，无需复杂数据结构；</li><li>一次性生成所有点对结果，适配批量查询场景（比如连续查询 10 组点对路径）。</li></ul><h5 id=避坑指南-1>避坑指南</h5><ul><li>INF 取值：绝对不能用<code>Integer.MAX_VALUE</code>（INF+INF 会溢出为负数），选 “略大于题目最大路径和” 的值（如 10000）；</li><li>循环顺序：必须先枚举中间点 k，再枚举起点 i、终点 j（k→i→j），顺序错则松弛逻辑完全失效；</li><li>松弛前判可达：必须先判断<code>dist[i][k] &lt; INF && dist[k][j] &lt; INF</code>，否则会用无效值更新路径。</li></ul><h4 id=3-dijkstra单源最短路径边权非负>3. Dijkstra（单源最短路径，边权非负）</h4><h5 id=什么时候用-2>什么时候用？</h5><p>仅需「单个起点到所有 / 指定终点的最短路径」，且边权非负，比如：从北京到上海的最短公路距离、网络中核心节点到其他节点的最小延迟。</p><h5 id=核心优势-2>核心优势</h5><ul><li>贪心策略保证最优解（边权非负时），基础版 O (n²) 适配 n≤200，堆优化版 O (m log n) 适配更大 n；</li><li>邻接表版比邻接矩阵版更省内存，适配稀疏图（边数少）。</li></ul><h5 id=避坑指南-2>避坑指南</h5><ul><li>边权限制：有负权边时绝对不能用（贪心策略失效），需改用 SPFA；</li><li>访问标记：BFS 版 Dijkstra 需在入队时标记访问，而非出队时（避免重复入队）；</li><li>无向图处理：将无向边视为双向有向边，邻接表中同时添加 u→v 和 v→u。</li></ul><h4 id=4-prim最小生成树稠密无向图>4. Prim（最小生成树，稠密无向图）</h4><h5 id=什么时候用-3>什么时候用？</h5><p>无向图中「连接所有顶点且总边权最小」，且是稠密图（边数多），比如：村村通公路（村庄多、道路密）、电网布线（节点密集）。</p><h5 id=核心优势-3>核心优势</h5><ul><li>基础版 O (n²) 适配稠密图，比 Kruskal 更高效（无需排序边）；</li><li>天然支持连通性判断：若最终加入 MST 的顶点数≠n，说明图不连通。</li></ul><h5 id=避坑指南-3>避坑指南</h5><ul><li>关键区别：Prim 的<code>dist</code>数组是「顶点到 MST 的最小边权」，而非 Dijkstra 的「到起点的距离」，切勿混淆；</li><li>起点选择：任选一个顶点（如 1）作为起点，最终 MST 总权值不变；</li><li>无向图处理：必须双向添加边，否则会漏连连通关系。</li></ul><h4 id=5-dfsbfs连通分量遍历--统计>5. DFS/BFS（连通分量遍历 / 统计）</h4><h5 id=什么时候用-4>什么时候用？</h5><p>需要「输出连通分量具体顶点」或「按指定顺序遍历图」，比如：列出所有连通的村庄、按编号递增顺序遍历图的连通区域。</p><h5 id=核心优势-4>核心优势</h5><ul><li>直观易实现，可精准控制遍历顺序（比如对邻接表排序实现编号递增访问）；</li><li>既能统计连通分量数，又能输出每个分量的具体顶点，兼顾 “统计” 和 “展示”。</li></ul><h5 id=避坑指南-4>避坑指南</h5><ul><li>遍历顺序：题目要求 “按编号递增访问邻接顶点” 时，需对每个顶点的邻接表执行<code>Collections.sort()</code>；</li><li>BFS 标记时机：必须在入队时标记<code>visited[v] = true</code>，而非出队时（避免重复入队导致死循环）；</li><li>多组数据：每组数据需重新初始化<code>visited</code>数组，避免前一组数据的标记影响结果。</li></ul><h4 id=6-并查集连通性快速查询>6. 并查集（连通性快速查询）</h4><h5 id=什么时候用-5>什么时候用？</h5><p>仅需「判断两点是否连通」或「统计连通分量数」，且数据规模大（n≤10000），比如：畅通工程（计算需建设的最少道路数）、大规模社交网络判断好友关系。</p><h5 id=核心优势-5>核心优势</h5><ul><li>路径压缩 + 按秩合并后，find/union 操作的时间复杂度近似 O (1)，效率远超 DFS/BFS；</li><li>代码简洁，内存占用低，适配海量边处理（比如 10 万条边）。</li></ul><h5 id=避坑指南-5>避坑指南</h5><ul><li>合并逻辑：必须先调用<code>find(a)</code>和<code>find(b)</code>找到根节点，再合并根节点（而非直接合并原顶点）；</li><li>路径压缩：查找时必须执行<code>parent[x] = find(parent[x])</code>，否则效率会骤降为 O (n)；</li><li>分量统计：统计连通分量数时，需调用<code>find(i)</code>验证是否为根节点，而非直接判断<code>parent[i] == i</code>（路径未压缩时会出错）。</li></ul><h3 id=二补充算法4-大高频核心拓展提分>（二）补充算法：4 大高频核心（拓展提分）</h3><h4 id=1-kruskal最小生成树稀疏无向图>1. Kruskal（最小生成树，稀疏无向图）</h4><h5 id=什么时候用-6>什么时候用？</h5><p>无向图中「连接所有顶点且总边权最小」，且是稀疏图（边数少，比如 n=1000 但 m=2000），比如：城市间建高铁（仅少数城市间有线路）。</p><h5 id=核心思路>核心思路</h5><ul><li>步骤 1：将所有边按权值升序排序；</li><li>步骤 2：用并查集遍历边，若边的两个顶点不在同一连通分量，则选中该边并合并分量；</li><li>步骤 3：直到选中 n-1 条边（生成 MST）或遍历完所有边（图不连通）。</li></ul><h5 id=避坑指南-6>避坑指南</h5><ul><li>边排序：必须按权值升序排序（保证选的是最小权值边）；</li><li>判环逻辑：用并查集判断边的两个顶点是否连通，连通则跳过（避免环）；</li><li>终止条件：选中 n-1 条边即可终止（MST 恰好有 n-1 条边），无需遍历所有边。</li></ul><h4 id=2-bellman-fordspfa单源最短路径负权边--判环>2. Bellman-Ford/SPFA（单源最短路径，负权边 / 判环）</h4><h5 id=什么时候用-7>什么时候用？</h5><p>单源最短路径场景中包含负权边，或需要判断是否存在负权环，比如：带手续费的路径规划（手续费为负权）、验证图中是否有负权环（路径长度无限减小）。</p><h5 id=核心思路-1>核心思路</h5><ul><li>Bellman-Ford：对所有边松弛 n-1 次（n 为顶点数），若第 n 次仍能松弛，则存在负权环；</li><li>SPFA（优化版）：用队列存储待松弛的顶点，仅松弛有更新的顶点，效率比 Bellman-Ford 高 10 倍以上。</li></ul><h5 id=避坑指南-7>避坑指南</h5><ul><li>负权环检测：SPFA 中若某个顶点入队次数 > n，则说明存在负权环；</li><li>效率优化：SPFA 中可跳过已确定最短路径的顶点（或用 SLF 优化队列）；</li><li>适用场景：仅在有负权边时使用，无负权边时优先选 Dijkstra（效率更高）。</li></ul><h4 id=3-tarjan强连通分量--割点割边>3. Tarjan（强连通分量 / 割点割边）</h4><h5 id=什么时候用-8>什么时候用？</h5><ul><li>有向图找强连通分量（顶点间互相可达），比如：压缩有向图为 DAG；</li><li>无向图找割点（删除后图连通分量增加）/ 割边（桥，删除后图连通分量增加），比如：网络故障排查（找关键节点 / 链路）。</li></ul><h5 id=核心思路-2>核心思路</h5><ul><li>用 DFS 遍历图，维护两个数组：<ul><li><code>dfn[u]</code>：顶点 u 的访问时间戳（首次访问顺序）；</li><li><code>low[u]</code>：顶点 u 能到达的最小时间戳（回溯时更新）；</li></ul></li><li>强连通分量：若<code>low[u] == dfn[u]</code>，则 u 是强连通分量的根节点；</li><li>割点：若<code>low[v] >= dfn[u]</code>（v 是 u 的子节点），则 u 是割点；</li><li>割边：若<code>low[v] > dfn[u]</code>，则 u→v 是割边。</li></ul><h5 id=避坑指南-8>避坑指南</h5><ul><li>递归栈处理：需用栈存储遍历过的顶点，找到强连通分量时弹出栈内顶点；</li><li>无向图处理：遍历邻接顶点时需跳过父节点（避免回边干扰）；</li><li>时间戳初始化：<code>dfn</code>和<code>low</code>数组初始化为 - 1，避免重复访问。</li></ul><h4 id=4-fleury-算法欧拉路径--回路一笔画>4. Fleury 算法（欧拉路径 / 回路，一笔画）</h4><h5 id=什么时候用-9>什么时候用？</h5><p>判断无向 / 有向图是否存在欧拉路径 / 回路，或输出具体的一笔画路径，比如：一笔画游戏、路径规划（不重复走边）。</p><h5 id=核心前提先判断是否存在>核心前提（先判断是否存在）</h5><ul><li>无向图：<ul><li>欧拉回路：所有顶点度数为偶数；</li><li>欧拉路径：恰好 2 个顶点度数为奇数（起点和终点）；</li></ul></li><li>有向图：<ul><li>欧拉回路：所有顶点入度 = 出度；</li><li>欧拉路径：恰好 1 个顶点入度 = 出度 - 1（起点），1 个顶点入度 = 出度 + 1（终点）。</li></ul></li></ul><h5 id=核心思路-3>核心思路</h5><ul><li>从起点出发，贪心选择非桥边（除非无其他边可选），遍历并删除该边；</li><li>递归遍历邻接顶点，直到遍历完所有边，回溯时记录路径（最终反转路径即为结果）。</li></ul><h5 id=避坑指南-9>避坑指南</h5><ul><li>先判条件：必须先验证欧拉路径 / 回路的度数条件，否则直接遍历会无效；</li><li>桥的判断：优先选非桥边（避免提前断开图），无其他边时再选桥；</li><li>路径记录：回溯时记录顶点，最终反转路径（因为递归是从终点回溯到起点）。</li></ul><h2 id=四期末速记图论算法选择口诀精华>四、期末速记：图论算法选择口诀（精华）</h2><ol><li>排序判环选拓扑，入度队列判环忙；</li><li>多源最短用 Floyd，三重循环别乱序；</li><li>单源非负 Dijkstra，贪心松弛效率强；</li><li>稠密 MST 选 Prim，稀疏 MST Kruskal；</li><li>连通遍历 DFS/BFS，连通查询并查集；</li><li>负权最短 SPFA，判环入队次数量；</li><li>强连通用 Tarjan，欧拉路径看度数；</li><li>最大流选 Dinic，分层增广路通畅。</li></ol><h2 id=五总结>五、总结</h2><p>图论算法的选择本质是「场景匹配」：</p><ul><li>必选 6 大算法覆盖了 80% 的基础场景（排序、最短路径、连通性、最小生成树），是期末复习的核心；</li><li>补充 4 大算法适配 20% 的特殊场景（负权边、稀疏图、强连通、一笔画），是提分和实战的关键。</li></ul></article></div></div></div></div></div></div></main></div><script type=application/javascript src=https://noctis-sikong.github.io/js/toc.js></script><link rel=stylesheet href=https://noctis-sikong.github.io/css/toc.css><div id=gitalk-container class=gitalk-container></div><link rel=stylesheet href=https://noctis-sikong.github.io/css/gitalk.css><script src=https://noctis-sikong.github.io/js/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:"Ov23liJPJ1rIHChpsuKV",clientSecret:"d73a8d88462d1ea39e6765fe614ad2f85f586622",repo:"blog-comments",owner:"Noctis-SiKong",admin:["Noctis-SiKong"],id:window.location.pathname.substring(0,50),distractionFreeMode:!1});document.addEventListener("DOMContentLoaded",function(){gitalk.render("gitalk-container")})</script></div><div class="footer container-xl width-full p-responsive"><div class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light"><a aria-label=Homepage title=GitHub class="footer-octicon d-none d-lg-block mr-lg-4" href=https://noctis-sikong.github.io/><svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.013 8.013.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0"><li class="mr-3 mr-lg-0">Theme by <a href=https://github.com/MeiK2333/github-style>github-style</a></li><li class="mr-3 mr-lg-0">GitHub and the Invertocat logo are trademarks of <a href=https://github.com/>GitHub, Inc.</a></li></ul></div><div class="d-flex flex-justify-center pb-6"><span class="f6 text-gray-light"></span></div></div></body><script type=application/javascript src=https://noctis-sikong.github.io/js/github-style.js></script></html>