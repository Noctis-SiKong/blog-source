---
title: ''
date: '2025-12-25T19:30:10+08:00'
draft: false
series: '数据结构与算法优化'
---

## 连通性问题

包含DFS/BFS（遍历求连通集）和并查集（Union-Find，连通性查询）

<!--More-->

### 子分类 1：DFS/BFS（遍历求连通集）

#### 核心场景（详细版）

DFS（深度优先搜索）和 BFS（广度优先搜索）是图遍历的基础，用于：

- 找出无向图中的所有**连通分量**（顶点间可达则属于同一分量）；
- 按指定顺序遍历（如 “从小编号出发，按编号递增访问邻接顶点”）；
- 典型应用：列出所有连通的村庄、判断图是否连通。

#### 算法思想（详细拆解）

##### DFS（深度优先，递归实现）

1. **核心思想**：“先深后广”，从起点出发，递归访问邻接顶点，直到无法深入，再回溯；
2. **步骤**：
   - 步骤 1：标记当前顶点为已访问，加入连通分量；
   - 步骤 2：按编号递增顺序遍历当前顶点的邻接顶点；
   - 步骤 3：若邻接顶点未访问，递归访问该顶点。

##### BFS（广度优先，队列实现）

1. **核心思想**：“先广后深”，从起点出发，先访问所有邻接顶点，再访问邻接顶点的邻接顶点；
2. **步骤**：
   - 步骤 1：将起点入队，标记为已访问；
   - 步骤 2：循环出队顶点，加入连通分量；
   - 步骤 3：按编号递增顺序遍历出队顶点的邻接顶点，未访问则入队并标记。

#### 通用精简代码（注释清晰，脱离题目限制）

```java
import java.util.*;

public class ConnectComponent {
    // DFS：收集单个连通分量
    private static void dfs(int u, List<List<Integer>> adj, boolean[] visited, List<Integer> component) {
        visited[u] = true;
        component.add(u);
        // 按编号递增访问邻接顶点（题目要求）
        for (int v : adj.get(u)) {
            if (!visited[v]) {
                dfs(v, adj, visited, component);
            }
        }
    }

    // BFS：收集单个连通分量
    private static void bfs(int u, List<List<Integer>> adj, boolean[] visited, List<Integer> component) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(u);
        visited[u] = true;
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            component.add(cur);
            // 按编号递增访问邻接顶点
            for (int v : adj.get(cur)) {
                if (!visited[v]) {
                    visited[v] = true;
                    queue.offer(v);
                }
            }
        }
    }

    // 通用入口：返回所有连通分量
    public static List<List<Integer>> getConnectComponents(int n, List<List<Integer>> adj, boolean useDFS) {
        boolean[] visited = new boolean[n];
        List<List<Integer>> components = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                List<List<Integer>> components = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                List<Integer> component = new ArrayList<>();
                if (useDFS) {
                    dfs(i, adj, visited, component);
                } else {
                    bfs(i, adj, visited, component);
                }
                components.add(component);
            }
        }
        return components;
    }

    // 复用入口（适配"列出连通集"）
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            int n = sc.nextInt(); // 顶点数（0~n-1）
            int e = sc.nextInt(); // 边数

            // 初始化邻接表，邻接顶点按编号排序
            List<List<Integer>> adj = new ArrayList<>();
            for (int i = 0; i < n; i++) adj.add(new ArrayList<>());
            for (int i = 0; i < e; i++) {
                int u = sc.nextInt();
                int v = sc.nextInt();
                adj.get(u).add(v);
                adj.get(v).add(u); // 无向图双向加边
            }
            // 按编号递增排序邻接顶点（满足题目遍历顺序要求）
            for (int i = 0; i < n; i++) Collections.sort(adj.get(i));

            // 1. 输出DFS结果
            List<List<Integer>> dfsRes = getConnectComponents(n, adj, true);
            for (List<Integer> comp : dfsRes) printComponent(comp);

            // 2. 输出BFS结果
            List<List<Integer>> bfsRes = getConnectComponents(n, adj, false);
            for (List<Integer> comp : bfsRes) printComponent(comp);
        }
        sc.close();
    }

    // 格式化输出连通分量
    private static void printComponent(List<Integer> component) {
        System.out.print("{ ");
        for (int i = 0; i < component.size(); i++) {
            if (i > 0) System.out.print(" ");
            System.out.print(component.get(i));
        }
        System.out.println(" }");
    }
}
```

#### 核心考点（详细解释）

1. **遍历顺序要求**：题目常要求 “从小编号出发，按编号递增访问邻接顶点”，需对邻接表排序（Collections.sort (adj.get (u))）；
2. **访问标记时机**：
   - DFS：递归前标记（避免重复递归）；
   - BFS：入队时标记（避免重复入队）；
3. **连通分量统计**：遍历所有顶点，未访问则启动一次 DFS/BFS，统计启动次数即为连通分量数；
4. **无向图处理**：邻接表必须双向加边，否则会漏连通关系。

#### 易错点（详细说明错误原因 + 正确做法）

| 易错点                 | 错误原因                        | 正确做法                                    |
| ---------------------- | ------------------------------- | ------------------------------------------- |
| 邻接表未排序           | 访问顺序不符合题目要求          | 对每个 adj.get (u) 执行 Collections.sort () |
| BFS 出队时才标记       | 重复入队，导致死循环 / 结果错误 | 入队时立即标记 visited [v] = true           |
| 无向图未双向加边       | 漏连通关系，连通分量统计错误    | 同时添加 u→v 和 v→u 的边                    |
| 多组数据未重置 visited | 前一组数据的标记影响后一组      | 每组数据重新初始化 visited 数组             |

### 子分类 2：并查集（Union-Find，连通性查询）

#### 核心场景（详细版）

并查集是高效的**连通性查询**数据结构，适合以下场景：

- 大规模数据（n≤10000）：比 DFS/BFS 更高效（操作接近 O (1)）；
- 仅需判断连通性 / 统计连通分量数（无需输出具体连通分量）；
- 典型应用：畅通工程（统计需建设的道路数 = 连通分量数 - 1）。

#### 算法思想（详细拆解）

并查集的核心是「路径压缩 + 按秩合并」，保证操作效率，步骤拆解如下：

1. **核心概念定义**：
   - 父节点数组 parent：parent [x] 表示 x 的父节点，初始时 parent [x] = x（自身为根）；
   - 秩数组 rank：rank [x] 表示以 x 为根的树的高度，用于按秩合并；
   - 根节点：parent [x] = x 的节点（连通分量的代表）。
2. **核心操作**：
   - 查找（find）：找节点 x 的根节点，同时执行路径压缩（使 x 直接指向根节点，减少后续查找次数）；
   - 合并（union）：将两个连通分量合并，按秩合并（小秩树合并到大秩树下，减少树高）。
3. **算法步骤**：
   - 步骤 1：初始化：parent [x] = x，rank [x] = 0；
   - 步骤 2：处理每条边：将边的两个顶点合并（union (u, v)）；
   - 步骤 3：统计连通分量数：遍历所有顶点，find (x) == x 的顶点数即为连通分量数；
   - 步骤 4：结果计算：需建设的道路数 = 连通分量数 - 1（畅通工程 1 核心）。

#### 通用精简代码（注释清晰，脱离题目限制）

```java
import java.io.*;
import java.util.StringTokenizer;

public class UnionFind {
    private int[] parent;
    private int[] rank;

    // 初始化并查集（1基）
    public UnionFind(int n) {
        parent = new int[n + 1];
        rank = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            parent[i] = i; // 初始父节点为自身
            rank[i] = 0;   // 初始秩为0
        }
    }

    // 查找（递归路径压缩，效率更高）
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩：x直接指向根节点
        }
        return parent[x];
    }

    // 合并（按秩合并）
    public void union(int a, int b) {
        int rootA = find(a);
        int rootB = find(b);
        if (rootA == rootB) return; // 已连通，无需合并

        // 小秩树合并到大秩树下
        if (rank[rootA] < rank[rootB]) {
            parent[rootA] = rootB;
        } else {
            parent[rootB] = rootA;
            if (rank[rootA] == rank[rootB]) {
                rank[rootA]++; // 秩相同，合并后根节点秩+1
            }
        }
    }

    // 统计连通分量数（根节点数）
    public int countComponents() {
        int count = 0;
        for (int i = 1; i < parent.length; i++) {
            if (find(i) == i) { // 根节点
                count++;
            }
        }
        return count;
    }

    // 复用入口（适配"畅通工程1"）
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        while ((line = br.readLine()) != null) {
            StringTokenizer st = new StringTokenizer(line);
            int n = Integer.parseInt(st.nextToken());
            if (n == 0) break; // 终止条件
            int m = st.hasMoreTokens() ? Integer.parseInt(st.nextToken()) : 0;

            UnionFind uf = new UnionFind(n);
            for (int i = 0; i < m; i++) {
                line = br.readLine();
                if (line == null || line.trim().isEmpty()) {
                    i--;
                    continue;
                }
                st = new StringTokenizer(line);
                int a = Integer.parseInt(st.nextToken());
                int b = Integer.parseInt(st.nextToken());
                uf.union(a, b); // 合并两个顶点
            }

            // 最少建设道路数 = 连通分量数 - 1
            System.out.println(uf.countComponents() - 1);
        }
        br.close();
    }
}
```

#### 核心考点（详细解释）

1. **路径压缩的作用**：将查找路径上的所有节点直接指向根节点，使后续查找操作从 O (n) 降为接近 O (1)；
2. **按秩合并的作用**：避免合并后形成链状树（如所有节点都指向一个根），保证树的高度尽可能小；
3. **连通分量数计算**：根节点数即为连通分量数（每个根节点代表一个连通分量）；
4. **效率对比**：并查集的 find/union 操作均为近似 O (1)，适合 n>1000 的大规模数据，比 DFS/BFS 更高效。

#### 易错点（详细说明错误原因 + 正确做法）

| 易错点              | 错误原因                         | 正确做法                                       |
| ------------------- | -------------------------------- | ---------------------------------------------- |
| 合并时未找根节点    | 直接合并原节点，导致连通关系错误 | 先 find (a) 和 find (b)，再合并根节点          |
| 未实现路径压缩      | 查找效率低，大规模数据超时       | 在 find 中执行 parent [x] = find (parent [x])  |
| 顶点编号未适配 1 基 | 数组越界（题目顶点从 1 开始）    | parent/rank 数组开到 n+1                       |
| 统计分量数时未 find | 路径未压缩，根节点判断错误       | 统计时执行 find (i) == i，而非 parent [i] == i |

### 连通性总结（辅助记忆）

| 方法    | 适用场景                  | 核心口诀                               | 优势               |
| ------- | ------------------------- | -------------------------------------- | ------------------ |
| DFS/BFS | 需输出连通分量具体顶点    | 标记访问→递归 / 队列访问邻接           | 直观，易实现       |
| 并查集  | 仅需判断连通性 / 统计分量 | 路径压缩 + 按秩合并，根节点数 = 分量数 | 效率高，适合大数据 |