---
title: '数组中「左侧最大 + 右侧最小」元素筛选'
date: '2025-12-25T19:30:10+08:00'
draft: false
series: '数据结构与算法优化'
---

# 「左侧最大 + 右侧最小」元素筛选

## 一、题目核心分析与算法思想

### 1. 题目功能定义（默认输入为正数）

给定长度为 n 的**正整数数组**，筛选出满足以下条件的元素（「递增关键元素」）：

- 第一个元素：大于左侧所有元素的最大值（左侧无元素，最大值为 0）且小于右侧所有元素的最小值；

- 中间元素（非首尾）：大于左侧所有元素的最大值 **且** 小于右侧所有元素的最小值；

- 最后一个元素：仅需大于左侧所有元素的最大值；

  <!--More-->

  最终输出满足条件的元素个数，以及这些元素（按原顺序，空格分隔）。

### 2. 核心算法思想对比

| 实现方式   | 算法思想                      | 时间复杂度 | 适用场景               | 核心优化点         |
| ---------- | ----------------------------- | ---------- | ---------------------- | ------------------ |
| 原代码     | 实时计算右侧最小值            | O(n²)      | 小规模正整数数组       | 无，重复计算超时   |
| 正数专用版 | 预处理（前缀最大 + 后缀最小） | O(n)       | 仅正整数数组           | 初始值简化为 0/MAX |
| 通用推广版 | 预处理（前缀最大 + 后缀最小） | O(n)       | 任意整数数组（含负数） | 初始值兼容所有数值 |

核心思想：**空间换时间**—— 通过提前预处理「前缀最大值数组」和「后缀最小值数组」，避免遍历每个元素时重复计算 “左侧最大” 和 “右侧最小”，将时间复杂度从 O (n²) 优化到 O (n)（期末算法优化高频考点）。

## 二、原代码拆解（正数场景下的问题）

### 1. 原代码核心逻辑（逐段解释）

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        String m = sc.nextLine().trim();
        String[] fule = m.split("\\s+"); // 分割输入字符串

        // 转换为整数数组（正数场景下无负数）
        int[] love = new int[fule.length];
        for (int i = 0; i < fule.length; i++) {
            love[i] = Integer.parseInt(fule[i]);
        }

        StringBuilder builder = new StringBuilder();
        int count = 0;

        int lmax = -1; // ❌ 正数场景下初始值可简化为0，-1无意义
        int rmin = findmin(love,0); // 实时计算右侧最小值，O(n²)超时
        for (int i = 0; i < n; i++) {
            boolean gmzz = false;
            // ❌ 无意义判断：rmin是右侧最小值，和当前元素无关
            if (rmin == love[i]) {
                rmin = findmin(love,i);
            }
            // 逻辑冗余：首尾判断可简化
            if (i == 0) {
                gmzz = love[i] > lmax &&  love[i] < rmin;
                if (love[i] > lmax) lmax = love[i];
            } else if (i == n - 1) {
                gmzz = love[i] > lmax;
                if (love[i] > lmax) lmax = love[i];
            } else {
                gmzz = love[i] > lmax && love[i] < rmin;
                if (love[i] > lmax) lmax = love[i];
            }
            // 收集结果
            if (gmzz) {
                if (count > 0) builder.append(" ");
                builder.append(love[i]);
                count++;
            }
        }

        sc.close();
        System.out.println(count);
        if (count > 0) System.out.println(builder.toString());
    }

    // 实时计算i右侧最小值，每次O(n)，总时间O(n²)
    public static int findmin(int[] a,int i){
        int n = a.length;
        int min = Integer.MAX_VALUE;
        for (int j = i + 1; j < n; j++) {
            if (a[j] < min) min = a[j];
        }
        return min;
    }
}
```

### 2. 原代码核心问题（正数场景下的优化点）

1. **初始值冗余**：正数场景下`lmax`初始为 - 1，可简化为 0（左侧无元素时最大值为 0，正数一定大于 0）；
2. **时间复杂度高**：`findmin`函数每次调用遍历 O (n)，n=1e5 时 O (n²) 直接超时；
3. **逻辑冗余**：首尾元素的判断分支可合并，无需单独写 3 个 if；
4. **命名不规范**：`love`/`fule`/`gmzz`等变量名无语义，复习时易混淆。

## 三、优化代码（分版本：正数专用 + 通用推广）

### 版本 1：正数专用版（简化初始值，适配题目默认场景）

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        // 输入处理：读取并转换为正整数数组
        String inputStr = sc.nextLine().trim();
        String[] strArr = inputStr.split("\\s+");
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(strArr[i]); // 题目保证输入为正数
        }

        // 步骤1：预处理前缀最大值数组（leftMax[i] = 0~i-1的最大值，正数场景初始为0）
        int[] leftMax = new int[n];
        leftMax[0] = 0; // 正数场景：左侧无元素，最大值为0（简化点）
        for (int i = 1; i < n; i++) {
            leftMax[i] = Math.max(leftMax[i-1], arr[i-1]);
        }

        // 步骤2：预处理后缀最小值数组（rightMin[i] = i+1~n-1的最小值）
        int[] rightMin = new int[n];
        rightMin[n-1] = Integer.MAX_VALUE; // 最后一个元素右侧无元素，最小值为极大值
        for (int i = n-2; i >= 0; i--) {
            rightMin[i] = Math.min(rightMin[i+1], arr[i+1]);
        }

        // 步骤3：遍历判断，收集结果（简化逻辑）
        StringBuilder resBuilder = new StringBuilder();
        int count = 0;
        for (int i = 0; i < n; i++) {
            boolean isQualified = false;
            // 合并判断逻辑：仅首尾特殊处理，中间通用
            if (i == 0) {
                isQualified = arr[i] < rightMin[i]; // 正数>0无需判断，仅需<右侧最小
            } else if (i == n-1) {
                isQualified = arr[i] > leftMax[i];
            } else {
                isQualified = arr[i] > leftMax[i] && arr[i] < rightMin[i];
            }

            // 收集结果
            if (isQualified) {
                if (count > 0) resBuilder.append(" ");
                resBuilder.append(arr[i]);
                count++;
            }
        }

        // 输出结果（格式控制）
        System.out.println(count);
        if (count > 0) System.out.println(resBuilder.toString());

        sc.close();
    }
}
```

### 版本 2：通用推广版（兼容负数，通用模板）

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        // 输入处理：兼容任意整数（正数/负数/0）
        String inputStr = sc.nextLine().trim();
        String[] strArr = inputStr.split("\\s+");
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(strArr[i]);
        }

        // 步骤1：预处理前缀最大值数组（兼容负数，初始为MIN）
        int[] leftMax = new int[n];
        leftMax[0] = Integer.MIN_VALUE; // 通用版：左侧无元素，最大值为整型最小值
        for (int i = 1; i < n; i++) {
            leftMax[i] = Math.max(leftMax[i-1], arr[i-1]);
        }

        // 步骤2：预处理后缀最小值数组（通用版）
        int[] rightMin = new int[n];
        rightMin[n-1] = Integer.MAX_VALUE; // 右侧无元素，最小值为整型最大值
        for (int i = n-2; i >= 0; i--) {
            rightMin[i] = Math.min(rightMin[i+1], arr[i+1]);
        }

        // 步骤3：遍历判断（通用逻辑，无需简化）
        StringBuilder resBuilder = new StringBuilder();
        int count = 0;
        for (int i = 0; i < n; i++) {
            boolean isQualified = false;
            if (i == 0) {
                isQualified = arr[i] > leftMax[i] && arr[i] < rightMin[i];
            } else if (i == n-1) {
                isQualified = arr[i] > leftMax[i];
            } else {
                isQualified = arr[i] > leftMax[i] && arr[i] < rightMin[i];
            }

            if (isQualified) {
                if (count > 0) resBuilder.append(" ");
                resBuilder.append(arr[i]);
                count++;
            }
        }

        // 输出结果
        System.out.println(count);
        if (count > 0) System.out.println(resBuilder.toString());

        sc.close();
    }
}
```

## 四、核心步骤解析（算法思想 + 代码对应）

### 1. 预处理前缀最大值数组（leftMax）

- 算法思想：**前缀数组**—— 提前计算每个位置左侧的最大值，避免重复遍历；

  - 正数专用版：`leftMax[0] = 0`（左侧无元素，正数一定大于 0，无需判断`arr[i] > leftMax[i]`）；
  - 通用推广版：`leftMax[0] = Integer.MIN_VALUE`（兼容负数，比如数组 [-5,-3,-1]，第一个元素 - 5 需判断`-5 > MIN`）；

- 示例（正数数组 [3,5,2,8,4]）：

  

  ```
  leftMax = [0,3,5,5,8]
  ```

### 2. 预处理后缀最小值数组（rightMin）

- 算法思想：**后缀数组**—— 倒序遍历计算每个位置右侧的最小值，核心是 “用后一个位置的结果推导当前位置”；

- 示例（正数数组 [3,5,2,8,4]）：

  

  ```
  rightMin = [2,2,4,4,MAX]
  ```

### 3. 遍历判断逻辑（正数场景简化）

| 元素位置 | 正数专用版判断条件                          | 通用推广版判断条件                          | 简化依据                  |
| -------- | ------------------------------------------- | ------------------------------------------- | ------------------------- |
| 第一个   | arr[i] < rightMin[i]                        | arr[i] > leftMax[i] && arr[i] < rightMin[i] | 正数 > 0（leftMax [0]=0） |
| 最后一个 | arr[i] > leftMax[i]                         | arr[i] > leftMax[i]                         | 无简化                    |
| 中间     | arr[i] > leftMax[i] && arr[i] < rightMin[i] | 同左                                        | 无简化                    |

### 4. 结果收集与输出

- 用`StringBuilder`而非字符串拼接：避免 O (n²) 的拼接耗时（期末小细节考点）；
- 格式控制：个数为 0 时不输出结果行，避免空行丢分。

## 五、期末复习核心考点

### 1. 算法思想考点

| 考点         | 核心提问方式（正数场景）                   | 解题关键                                                     |
| ------------ | ------------------------------------------ | ------------------------------------------------------------ |
| 空间换时间   | 正数数组筛选元素，如何优化 O (n²) 超时？   | 预处理前缀 / 后缀数组，O (n) 空间换 O (n) 时间，正数可简化初始值 |
| 前缀数组构建 | 正数场景下前缀最大值数组初始值为何是 0？   | 左侧无元素，正数一定大于 0，无需额外判断                     |
| 逻辑简化     | 正数场景下第一个元素的判断条件为何可简化？ | 省略 “大于左侧最大值” 的判断，仅保留 “小于右侧最小值”        |

### 2. 易错点总结（期末避坑清单）

1. **初始值错误**：
   - 正数场景下`leftMax[0]`设为 - 1 → 修正为 0；
   - 通用版`leftMax[0]`设为 0 → 修正为`Integer.MIN_VALUE`（兼容负数）；
2. **时间复杂度**：
   - 实时计算右侧最小值（O (n²)）→ 预处理后缀数组（O (n)）；
3. **逻辑冗余**：
   - 正数场景下重复判断`arr[i] > leftMax[i]` → 省略该判断，简化代码；
4. **输出格式**：
   - 个数为 0 时输出空行 → 需判断`count > 0`后再输出。

### 3. 同类题型扩展（正数场景举一反三）

| 题型                  | 核心思想复用                                            | 差异点                                                       |
| --------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 找左侧最小 + 右侧最大 | 筛选 arr [i] < 左侧最小 && arr [i] > 右侧最大的正数元素 | 前缀数组改为 “前缀最小（初始为 MAX）”，后缀数组改为 “后缀最大（初始为 0）” |
| 正数数组前缀和        | 求子数组和、区间和                                      | `prefixSum[i] = prefixSum[i-1] + arr[i]`，初始值为 0，逻辑和前缀最大一致 |

## 六、复习建议

1. 背记双版本模板（期末按需选择）：

   ```java
   // 正数专用版前缀数组
   int[] leftMax = new int[n];
   leftMax[0] = 0;
   for (int i=1; i<n; i++) leftMax[i] = Math.max(leftMax[i-1], arr[i-1]);
   
   // 通用推广版前缀数组
   int[] leftMax = new int[n];
   leftMax[0] = Integer.MIN_VALUE;
   for (int i=1; i<n; i++) leftMax[i] = Math.max(leftMax[i-1], arr[i-1]);
   ```

   

2. 手动模拟正数样例：

   - 输入：n=5，数组 [3,5,2,8,4]
     - leftMax（正数版）：[0,3,5,5,8]
     - rightMin：[2,2,4,4,MAX]
     - 满足条件的元素：
       - 第一个元素 3：3 < 2？不满足；
       - 第二个元素 5：5>3 且 5<2？不满足；
       - 第三个元素 2：2>5？不满足；
       - 第四个元素 8：8>5 且 8<4？不满足；
       - 第五个元素 4：4>8？不满足；
     - 输出：0；

3. 重点区分：正数场景的简化逻辑仅适用于 “输入全为正数”，通用版可应对所有场景，期末优先记通用版（避免场景判断错误）。

## 七、核心总结

这道题在 “默认输入为正数” 的场景下，核心优化点可浓缩为 3 点：

1. **空间换时间**：预处理前缀 / 后缀数组，将 O (n²)→O (n)；
2. **初始值简化**：正数场景下`leftMax[0] = 0`，省略第一个元素 “大于左侧最大值” 的判断；
3. **逻辑精简**：合并首尾元素的判断分支，减少冗余代码。